import os
import logging
import ast
import pandas as pd
import numpy as np
import re

from utils.globals import *
from utils.exceptions import *
from datetime import datetime
from langchain import PromptTemplate, LLMChain
from langchain.chat_models import ChatOpenAI



def extract_dict(input):
    reg_ex = r'\{[^{}]*\}'
    coincidence = re.search(reg_ex, input, re.DOTALL)

    if coincidence:
        return coincidence.group(0)
    else:
        return None


def to_dict(input):
    try:
        dictionary = ast.literal_eval(extract_dict(input))
    except BadDictionaryGeneration as e:
        print(f'Bad dictionary generation for user assistant: {e}')
        dictionary = {}
    return dictionary


class user_assistant:
    def __init__(self, ask_about):
        self.prompt = """
        Assistant that detects if this sentence '{user_msg}' is asking about any of these topics: {ask_about}. 
        Answer which question is being asked in a dictionary-like way, using True or False.
        List the questions in the same order and written the same way as here {ask_about}.
        Always use the dictionary format using brackets, without any other content but the questions and the evaluation.
        """
        self.logger = logging.getLogger('my_logger')
        self.assistant_role_prompt = PromptTemplate(
            input_variables=["user_msg", "ask_about"],
            template=self.prompt)
        self.llm = ChatOpenAI(model="gpt-4o")
        self.chain = LLMChain(llm=self.llm, prompt=self.assistant_role_prompt)
        self.ask_about = ask_about
        self.request = None

    def get_request(self, usr_msg=None):
        response = self.chain.run(user_msg=usr_msg, ask_about=str(self.ask_about))
        # print(f'response: {response}')
        # show_print(f'response: {response}')
        logging.getLogger().verbose(f'dictionary generated by user assistant: {response}')
        request_register = to_dict(response)

        self.request = request_register

class chatbot_assistant:
    def __init__(self, ask_about):
        self.prompt ="""
        You're an assistant implemented in a chatbot that has to process the conversation the chatbot and the user 
        are having. You have to focus on detecting if this sentence by the chatbot '{chatbot_msg}' is answering to what 
        the user is saying in this sentence '{user_msg}'. You will also have to detect if the user asked about anything
        in this list of questions '{ask_about}', and reply which question is being answered in a python dictionary-like 
        way, using True or False. If the chatbot is answering what the user asked but it's not a question in the list,
        everything should stay as False.        
        List the questions in the same order and written the same way as here {ask_about}.
        Always use the dictionary format using brackets, without any other content but the questions and the evaluation.
        
        """
        # """
        # Assistant that detects if this sentence '{chatbot_msg}' is responding to any of these questions: {ask_about}.
        # Answer which question is being answered in a dictionary-like way, using True or False.
        # List the questions in the same order and written the same way as here {ask_about}.
        # Always use the dictionary format using brackets.
        # """
        self.logger = logging.getLogger('my_logger')
        self.assistant_role_prompt = PromptTemplate(
            input_variables=["chatbot_msg", "ask_about", 'user_msg'],
            template=self.prompt)
        self.llm = ChatOpenAI(model="gpt-4o")
        self.chain = LLMChain(llm=self.llm, prompt=self.assistant_role_prompt)
        self.ask_about = ask_about
        self.gathering_register = self.create_dataframe(ask_about)

    def extract_dataframe(self, path, test_name):

        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        file_path = os.path.join(path, f'{test_name}_{timestamp}.csv')

        self.gathering_register.to_csv(file_path, index=False, sep=';', header=True,
                                       columns=['ask_about', 'is_answered', 'response'])

    def create_dataframe(self, ask_about):

        df = pd.DataFrame()

        df["ask_about"] = ask_about
        df["is_answered"] = np.full(len(ask_about), fill_value=False)
        df["response"] = np.full(len(ask_about), fill_value=np.nan)
        df["response"] = df["response"].astype("object")

        return df

    def add_to_register(self, chatbot_msg, dictionary, user_msg):

        df = self.gathering_register

        ab_index = []

        for i, question in enumerate(self.ask_about):

            for dfindex in df.index:
                if df.loc[dfindex, 'ask_about'] == question:  # Condici√≥n para actualizar
                    df.loc[dfindex, 'is_answered'] = dictionary[question]
                    if df.loc[dfindex, "is_answered"]:
                        df.loc[dfindex, "response"] = chatbot_msg
                        ab_index.append(i)
        ab_ndarray = self.ask_about
        ab_user_ndarray = user_msg.ask_about

        self.ask_about = np.delete(ab_ndarray, ab_index).tolist()
        user_msg.ask_about = np.delete(ab_user_ndarray, ab_index).tolist()

    def request_control(self, user, chatbot):
        coincidence = False

        for key in user:
            if user.get(key) == chatbot.get(key):
                coincidence = True
                break

        if coincidence:
            return chatbot
        else:
            return {key: False for key in chatbot}

    def response(self, chatbot_msg, user_msg): #user_msg?? dictionary

        chatbot_response = self.chain.run(chatbot_msg=chatbot_msg, ask_about=str(self.ask_about), user_msg = user_msg)

        logging.getLogger().verbose(f'dictionary generated by chatbot assistant: {chatbot_response}')
        chatbot_response = to_dict(chatbot_response)

        chatbot_response = self.request_control(user_msg.request, chatbot_response)
        self.add_to_register(chatbot_msg, chatbot_response, user_msg)
        return

